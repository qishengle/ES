------------------pyhton----------------
1 单行注释#, 多行 ‘’‘ 。。。’‘’

2 除/，整除//，取余%
pytho 3.0之前的版本，执行除法运算 / 时有个小陷阱，表达式2/3进行计算时，结果为0，这是因为参加运算的两个操作数都是整数，所以运算符/进行的是整除法，但是表达式2.0/3的结果却是0.66666666666666663，这是因为操作数中的2.0是浮点数，所以运算符/进行的是真除法。表达式2//3和2.0//3进行求值时，进行的都是整除法，只不过返回值一个是整型，一个是浮点型而已

3 r'...' 表示普通字符，没有转义；u'...' 表示UNICODE字符【两字节】；
  b'...' 表示bytes类型【一个字节】的字符串，使用encode()转换编码
  'abc'.encode('ascii') <==> b'abc'
     '中文'.encode('utf-8')  <==> b'\xe4\xb8\xad\xe6\x96\x87'

  ## '\u4e2d\u6587'  <==> '中文'

4 空值是None
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

5 ord()获取字符整数表示 <==> chr()把编码数字转换为字符

6 len()函数计算的是str的字符/字节数，list元素个数，

7 格式化占位符， 使用%连接:%s 字符串；%f 浮点数；%d 整数；%x 十六进制（%% 表示%自身）
    '%003d' % 11 -------- 三位整数，0补齐
    '%.2f' % 3.1415 -----保留两位小数

8 list  列表 ['aa','aa',... ]
     append()  添加到末尾     pop()  删除末尾
	 insert(i)  添加到指定位置   pop(i)   删除指定位置
	 list1[i]=item  元素赋值，元素item也可是列表

9  tuple  元组('aa','aa',...),和list非常类似，但是tuple一旦初始化就不能修改----指向不变
    因为tuple不可变，所以代码更安全。  当定义一个tuple时，tuple的元素就必须被确定下来

    只有1个元素的tuple定义时必须加一个逗号,，来消除歧义,如： t=(1,)
   tuple的元素不可变，但元素本身是list的话，list的子元素是可变的

10  if  elif  else
  if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，
    就忽略掉剩下的elif和else
  if x:  只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False

  input()读取用户的输入,input()返回的数据类型是str，不能直接和整数比较

11  循环 for...in  或  while
  for x in ... 循环把每个元素代入变量x，然后执行缩进块的语句
  while  只要条件满足，就不断循环，条件不满足时退出循环

  range()函数，可以生成一个整数序列，再通过list()函数可以转换为list,如 list(range(5))

    不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。

12  dict 使用键-值（key-value）存储，具有极快的查找速度
  如  d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
    	赋值 d['Michael']=90
	删除一个key，用pop(key)方法，对应的value也会从dict中删除：d.pop('Bob')

	如果key不存在，dict就会报错.避免key不存在的错误，有两种办法，
	一是通过in判断key是否存在: 'Thomas' in d  结果返回false
	二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：
		d.get('Thomas')  返回None，交互式命令行不显示结果
		d.get('Thomas', -1)  返回 -1

	dict内部存放的顺序和key放入的顺序是没有关系的。

dict和list比较
		dict									list

    1 查找和插入的速度极快，不会随key的增加而变慢   *  查找和插入的时间随着元素的增加而增加；
    2 需要占用大量的内存，内存浪费多。                        *  占用空间小，浪费内存很少。

dict可以用在需要高速查找的很多地方，dict的key必须是不可变对象。
dict根据key来hash计算value的存储位置
在Python中，字符串、整数等都是不可变的，因此，可以作为key。而list是可变的，就不能作为key：

13  set类似dict，是一组key的集合,但没有value。不可以放入可变对象.重复元素在set中自动被过滤
要创建一个set，需要提供一个list作为输入集合：s = set([1, 1, 2, 2, 3, 3])

    添加元素 add(key)    删除元素 remove(key)

set可以看成数学上的无序和无重复元素的集合，因此，两个set可以做交集、并集等操作

14  不变对象与可变对象
str是不变对象，而list是可变对象。
不变对象，调用对象自身的任意方法，不会改变该对象自身的内容。这些方法会创建新的对象并返回；
可变对象，则相反。

如果有一个函数内部的变量赋值，该变量被认为是本地的。Python 3.x引入了nonlocal关键字。
只要在闭包内使用nonlocal，就能让解释器在外层函数中查找变量，不必用global

把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据(即指针相同);
a = 'ABC'
b = a
a = 'XYZ'
print(b)---------------------结果是'ABC'



-------------------------------函数-------------------------------
函数名是指向一个函数对象的引用，可以把函数名赋给一个变量，相当于给这个函数起“别名”
查看函数用法 help(函数名)
定义一个函数要使用def语句
如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
return None可以简写为return。

abs(),max(),min(),int(),hex()-------把一个整数转换为16进制
pass可以用来作为占位符

enumerate参数为可遍历的变量，如 字符串，列表等； 返回值为enumerate类,
enumerate还可以接收第二个参数，用于改变索引起始值

默认参数可以简化函数的调用。设置默认参数时，有几点要注意：
一是必选参数在前，默认参数在后，否则Python的解释器会报错
（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。
  变化小的参数就可以作为默认参数。

定义默认参数要牢记一点：默认参数必须指向不变对象！

当不按顺序提供部分默认参数时，需要把参数名写上

----可变参数,可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple
*nums表示把nums这个list的所有元素作为可变参数传进去。
Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去

----关键字参数,允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}

**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，
kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。

-----命名关键字参数
和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数.
命名关键字参数必须传入参数名

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了;如果没有
可变参数，就必须加一个*作为特殊分隔符


定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的



小结

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。


------递归
解决递归调用栈溢出的方法是通过 尾递归优化---尾递归是指，在函数返回的时候，调用自身本身，并且，
return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，
都只占用一个栈帧，不会出现栈溢出的情况

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

一个问题能否用递归求解，要看这个问题能否逐层分解成一个个规模依次变小的小问题，同时有能够进行判断的下限
 
**汉诺塔打印实时状态问题-----显示那个盘子在移动(记忆功能，要用 栈)

python中函数嵌套定义了多个，如何调用？------默认首个，余下的并列的外界无法调用



